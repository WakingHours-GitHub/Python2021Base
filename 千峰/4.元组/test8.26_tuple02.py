# 讲解一下元组中的另一个特点: 元组的拆包
t1 = (4,7,3)
a,b,c = t1 # 这就是拆包
print(a,b,c) # 4 7 3
# a,b =t1   # ValueError: too many values to unpack(拆包) (expected（希望，盼望） 2)
# x,y,z=(6,) #ValueError: not enough values to unpack (expected 3, got 1)
# 拆包唯一需要注意的就是, 对应元素的个数应该一致

a = t1 # 此时不是拆包, 而是把元组t1整个付给a了
print(a, type(a)) # (4, 7, 3) <class 'tuple'>
# 若想一个元素拆包的话, 那么就需要在后面跟上,
t = (4,)
a = t
b, = t
print(a, type(a)) # (4,) <class 'tuple'>

print(b, type(b)) # 4 <class 'int'>


# 当变量与元组中的元素个数不同时：
t1 = (2,5,8,8,9,7)
a,*_,c = t1
print(a,c,_) # 2 7 [5, 8, 8, 9]
# 可以看出当元组元素与变量个数不同的时候,我们可以使用*+名字,占位,返回的结果是一个列表
a,b,*c = t1
print(a,b,c) # 2 5 [8, 8, 9, 7]
print(a,b,*c) # 2 5 8 8 9 7 # 后面没有列表了
# 只要用*名字 占位即可, 元组会根据变量个数和位置,赋值
# 多个元素以列表形式返回

'''
同理:
对于字符串和列表也同理:
x,y,*z = 'hello' -return-> x = 'h' y = 'e' z = ['l','l','o']
x,y,*z = ['a', 'b', 'c', 'd', 'e']  返回: x = 'a' y = 'b' z = ['c', 'd', 'e']
'''

"""
让我们了解一下拆包的底层:
t1 = (9,4,8,6)
x, *y = t1  <==> x, *y = (9,4,8,6)
底层, 拆包: -> 9,4,8,6
然后分别赋值:
x = 9
*y = 4, 8, 6 # 此时编译器注意到了这个带*的变量, 系统就准备了一个容器
并且后面没有元素了, 于是系统就自动装箱
y = [4, 8, 6]  # 此时注意*y = 4, 8, 6
所以在打印的时候, 就为:9, [4 ,8, 6]
所以print(y) # [4,8,6]
而:print(*y) # 4,8,6 # 这是因为底层看到了一个列表前面有一个*,于是系统就会自动拆箱, 所以打印出的就是散列的元素

# 如何理解上面的过程呢?
*y = 4,8,6 # 赋值, 将一些散列的数据赋值给*y, 相当于装包
print(*[4,8,6]) # 打印, 将已经整合好的数据(列表),拆包(前面带有*,拆包,成为散列的数据)

"""
# print(*[4,5,6,'p']) # 4 5 6 p # *[]就是散列的数据

t1 = (9,) # 这样声明是一个元组
x,*y = t1
print(x,y) # 9 [] # 这样就返回一个空列表
print(type(y)) # <class 'list'>
y.append('a') # 添加元素
y.append('b')
print(y) # ['a', 'b']
print(*y) # a b



'''
元组简单总结:
元组:
1. 符号: () 圆括号中放入多个元素并且用逗号分割,我们就认为是元组类型
2. 关键字: tuple
3. 元组的元素只能获取(查询), 不能增删改查

可以使用的运算符:
+
*
is  not is
in  not in
# 列表能使用的运算符,元组也一样能用

系统函数:(与列表大致相同)
max()
min()
sum()
len()
sorted() -> 元素排序, 默认升序
tuple() -> 强转

元组的内建函数
tuple.index(ele) # 根据元素返回元素的index
tuple.count(ele) # 返回ele在调用的tuple中有多少个

元组的特性: 拆装包
x, *y = (1,2,3,4,5)
print(y) # [2,3,4,5] # 装包
print(*y) # 2,3,4,5 # *符号,拆包

'''
# 下面我们来具体介绍一下:

# 演示+在元组中的应用
t2 = (4,5) + (1,2)
print(t2) # (4, 5, 1, 2) # 拼接起来

t3 = (1,2)*2
print(t3) # (1, 2, 1, 2) # 倍数

print(t2 is t3) # 比较地址是否一样
# not is 就是比较地址是否不一样

print(3 in t3) # 看3这个元素是否在t3中

print(len(t2)) # 4 # 只要是可迭代的, 就都可以用len计算长度

print(sorted(t2)) # sorted()排序, 返回一个排好序的列表

print(tuple(sorted(t2))) # 排序返回一个列表, 然后强转成为tuple





