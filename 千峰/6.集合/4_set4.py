# 进阶: 可变 和 不可变 的概念
# 可变: 对象所指向的内存中的值是可以改变的, 并且还是原来的内存地址
# 不可变: 对象所指向的内存中的数值是不可以改变的, 如需改变, 则重新重新指向一个新的地址空间
# 区分可变与不可变的一个关键点: 当改变变量时候, 地址变化,就是不可变的, 地址不变,就是可变的

# 我们一个一个类型元素来试

# 数值形式
num = 10
print(id(num))
num = 20
print(id(num))
# 两次打印的数值不一样, 但是数值型是不可变类型吗?
# 我们说过py是有小整数常量池的. 
# num = 10 就在小整数常量池创建10,
# num = 20 小整数常量池没有20, 所以就新建一个20, 然后num指向它
# 所以, 地址改变了
print('<=============================>')

# 字符串型:
s1 = "abc"
print(id(s1))
s1 = "zxc"
print(id(s1))
# 地址仍然不一样, 说明新的字符串是新开辟的, 而原来的地址内容没有改变

# 元组类型 
t1 = (1,2,3)
print(id(t1))
t1 = (1,2)
print(id(t1))
# 地址不一样, 说明元组是不可变的

# 下面开始介绍可变的:
# 可变的: 对象所指向的内存中的值是可以改变的
# 可变类型：字典dict 列表list 集合set
# 扩展: frozenset() 不可变
list1 = [1, 2, 3, 4, 5]
print(list1,id(list1))
list1.pop() # 删除最后一个元素
print(list1,id(list1))
# 地址不变
# 同理, append增加也不不改变list1的地址

# 字典
dict = {1:"aa", 2:"bbb"}
print(dict, id(dict))
dict.pop(1) # 删除key对应的键值对
print(dict, id(dict))
# 地址一样的

# 集合
set1= {3,5,6,8}
print(set1,id(set1))
set1.discard(3)
print(set1,id(set1))
# 地址仍是一样的, 所以是可变类型的

# frozenset() # 返回一个冻结的集合 冻结后的集合不能再添加或者删除任何元素
fset = frozenset(set1) # {3,6,8}
print(fset, id(fset))
fset = frozenset({3,6})
print(fset, id(fset))
# 地址变了, 因为set1冻结了, 无法增加或者删除元素了, 此时任何类型都是不可变的

"""
综上:
可变: 当改变对象所指向的数值时, 是可以改变的, 并且地址不变
可变类型: 列表, 集合, 字典

不可变: 当改变对象所指向的元素时, 改变必须要重新创建一个地址, 地址发生改变
不可变类型: int(小整数) str 元组 frozenset()冻结后的元素是不可变的
"""